"use strict";

var _ibmmq = _interopRequireDefault(require("ibmmq"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class IBMMQWrapper {
  constructor(connName, channelName, queueManager, queueName) {
    this.MQC = _ibmmq.default.MQC;
    this.connName = connName;
    this.channelName = channelName;
    this.queueManager = queueManager;
    this.queueName = queueName;
    this.connectionHandle;
    this.queueHandle; // Params for Connect

    this.cd = new _ibmmq.default.MQCD();
    this.cno = new _ibmmq.default.MQCNO();
    this.cd.ConnectionName = connName;
    this.cd.ChannelName = channelName;
    this.cno.ClientConn = this.cd;
    this.md = new _ibmmq.default.MQMD();
  }

  getMessages(cb, opts) {
    _ibmmq.default.ConnxPromise(this.queueManager, this.cno).then(hConn => {
      console.log("MQCONN to %s successful ", this.queueManager);
      const od = new _ibmmq.default.MQOD();
      od.ObjectName = this.queueName;
      od.ObjectType = this.MQC.MQOT_Q;
      const openOptions = this.MQC.MQOO_INPUT_AS_Q_DEF;
      return _ibmmq.default.OpenPromise(hConn, od, openOptions);
    }).then(hObj => {
      console.log("MQOPEN of %s successful", this.queueName);
      this.queueHandle = hObj;
      const gmo = new _ibmmq.default.MQGMO();

      if (opts) {
        gmo.Options = this.MQC[opts.options[0]] || this.MQC[opts.options[1]];
        gmo.MatchOptions = this.MQC[opts.matchOptions];
        gmo.WaitInterval = this.MQC[opts.waitInterval];
      }

      _ibmmq.default.Get(hObj, this.md, gmo, (err, hObj, gmo, md, buff, hConn) => {
        this.connectionHandle = hConn;
        cb(err, buff);
      });
    }).catch(err => console.log(this.formatErr(err)));
  }

  putMessage(msg, opts) {
    _ibmmq.default.ConnxPromise(this.queueManager, this.cno).then(hConn => {
      console.log("MQCONN to %s successful ", this.queueManager);
      this.connectionHandle = hConn;
      const od = new _ibmmq.default.MQOD();
      od.ObjectName = this.queueName;
      od.ObjectType = this.MQC.MQOT_Q;
      const openOptions = this.MQC.MQOO_OUTPUT;
      return _ibmmq.default.OpenPromise(hConn, od, openOptions);
    }).then(hObj => {
      console.log("MQOPEN of %s successful", this.queueName);
      this.queueHandle = hObj;
      const pmo = new _ibmmq.default.MQPMO();

      if (opts) {
        pmo.Options = this.MQC[opts.options[0]] || this.MQC[opts.options[1]] || this.MQC[opts.options[2]];
      }

      _ibmmq.default.PutPromise(this.queueHandle, this.md, pmo, msg);
    }).then(() => _ibmmq.default.ClosePromise(this.queueHandle, 0)).then(() => _ibmmq.default.DiscPromise(this.connectionHandle)).then(() => console.log("Done")).catch(err => console.log(this.formatErr(err)));
  }

  commit() {
    _ibmmq.default.Cmit(this.connectionHandle);
  }

  backout() {
    _ibmmq.default.Back(this.connectionHandle);
  }

  formatErr(err) {
    if (err) {
      return `MQ call failed at ${err.message}`;
    }

    return "MQ call successful";
  }

}

module.exports = IBMMQWrapper;
