global-policy: 1.0.0

info:
  name: ibk-policy
  title: Ibk Policy
  version: 2.0.0

gateways:
  - datapower-api-gateway

assembly:
  execute:
    - log:
        version: 2.0.0
        mode: gather-only    
    - gatewayscript:
        version: 2.0.0
        title: gatewayscript
        source: |-
          var config = {
            "redact": {
              "anywhere": {
                "full": new Set(["customerCode", "Authorization"]),
                "cc": new Set(["description"])
              },
              "path": {
                "full": new Set(["data.movements.movementBranch"]),
                "cc": new Set(["data.movements.movementPostDate"])
              } 
            },
            "extract": {
              "@traceId": "redacted.request_http_headers_obj.trace-id",
              "@consumerId": "redacted.request_http_headers_obj.consumerId",   
              "@timestamp": "redacted.request_http_headers_obj.timestamp",
              "@message": "redacted.response_body",
              "@querystring": "redacted.query_string",
              "@request_http_headers": "redacted.request_http_headers",
              "@gateway_ip": "plain.log.gateway_ip",
              "@branchId": "redacted.query_string_obj.branchCode",
              "@currency": "redacted.query_string_obj.currency",
              "ipOrigen": "redacted.request_http_headers_obj.ipOrigen"
            }
          }

          var apim = require('apim');
          //apim.setvariable("log.mivariable", "elvalor46global");
                      
          try {
            var doAudit = apim.getvariable("audit");
            if (doAudit == "false") {
              return;
            }
            var ibkredact = new IbkRedactUtils();
            var input = ibkredact.createInput(apim.getvariable("log"), config);
            var custom_log_record = ibkredact.createCustomLogRecord(input, config);
            apim.setvariable("log.ibkrec", custom_log_record);
            apim.setvariable("log.response_body", input.redacted.response_body);
            apim.setvariable("log.query_string", input.redacted.query_string);
          } catch(err) {
            apim.error('MyError', 500, 'Internal Error', err.stack);
          }            
          
          // ******* inicio copia hacia global policy
          function IbkRedactUtils() {
            this.createInput = function(log, config) {
              var parsedBody = JSON.parse(log.response_body);
              this.redact(parsedBody, null, config.redact);

              var request_http_headers_obj = this.arrayToObject(log.request_http_headers);
              this.redact(request_http_headers_obj, null, config.redact);
              var query_string_obj = this.decodeQueryString(log.query_string);
              this.redact(query_string_obj, null, config.redact);
              var response_body_obj = JSON.parse(log.response_body);
              this.redact(response_body_obj, null, config.redact);

              return {
                redacted: {
                  "request_http_headers_obj": request_http_headers_obj,
                  "request_http_headers": JSON.stringify(request_http_headers_obj),
                  "query_string_obj": query_string_obj,
                  "query_string": this.encodeQueryString(query_string_obj),
                  "response_body_obj": response_body_obj,
                  "response_body": JSON.stringify(response_body_obj),
                },
                plain: {
                  log: log
                }
              };
            }

            this.createCustomLogRecord = function(input, config) {
              let result = {};
              for (var k in config.extract) {
                result[k] = this.navigateOpt(input, config.extract[k]);
              }
              return result;
            }

            this.navigateOpt = function(obj, path) {
              var cursor = obj;
              var parts = path.split(".");
              for (var i = 0; i < parts.length; ++i) {
                cursor = cursor[parts[i]];
                
                if (cursor == undefined) {
                  return null;
                }
              }
              return cursor;
            }


            // copied from https://stackoverflow.com/a/3855394
            this.decodeQueryString = function(queryStr) {
              if (queryStr == "") return {};
              var elements = queryStr.split('&');
              var result = {};
              for (var i = 0; i < elements.length; ++i)
              {
                var keyval = elements[i].split('=', 2);
                if (keyval.length == 1)
                  result[keyval[0]] = "";
                else
                  result[keyval[0]] = decodeURIComponent(keyval[1].replace(/\+/g, " "));
              }
              return result;
            }

            // copied from https://stackoverflow.com/a/34209399
            this.encodeQueryString = function(params) {
              return Object.keys(params)
              .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))
              .join('&');
            }

            //console.log(arrayToObject(obj.request_http_headers));

            // apic headers are in an array of elements, each with 1 key.
            // This function converts that useless format into an object with several keys
            this.arrayToObject = function(objArray) {
              var obj = {};
              var len = objArray.length;
              for (var i = 0; i < len; i++) {
                var innerObj = objArray[i];
                for (var key in innerObj) {
                  obj[key] = innerObj[key];
                }
              }
              return obj;
            }

            this.redact = function(obj, path, redactConfig) {
              for (var k in obj) {    
                this.redactAny(obj, obj[k], path, k, redactConfig);
              }
            }

            this.redactAny = function(parent, value, path, k, redactConfig) {
              if (Array.isArray(value)) {
                var len = value.length;
                for (var i = 0; i < len; i++) {
                  this.redactAny(parent, value[i], path, k, redactConfig);
                }
              } else if (typeof value === 'object') {
                this.redact(value, this.buildPath(path,k), redactConfig);
              } else {
                this.redactField(parent, k, path, redactConfig);
              } 
            }

            this.buildPath = function(path, k) {
              var parts = [];
              if (path != null) {
                parts.push(path);
              }
              parts.push(k);
              return parts.join(".", parts);
            }

            this.redactField = function(parent, k, path, redactConfig) {
              if (!parent.hasOwnProperty(k)) {
                return;
              }
              var path = this.buildPath(path,k);
              // console.log("path = " + path);
              // TODO: handle optional full
              if (redactConfig.anywhere.full.has(k) || redactConfig.path.full.has(path)) {
                //console.log(buildPath(path,k));
                parent[k] = "*".repeat(String(parent[k]).length);
              }

              if (redactConfig.anywhere.cc.has(k) || redactConfig.path.cc.has(path)) {
                //console.log(buildPath(path,k));
                parent[k] = this.partialRedactCCnumbers(parent[k]);
              }
            }

            this.partialRedactCCnumbers = function(ccNumbers) {
              // With this regex "(.*?)(.{0,6})(.{0,4})" less code is used
              // but performance is worse
              if (ccNumbers == null) {
                return null;
              }
              ccNumbers = ccNumbers.replace(/ /g, "");
              ccNumbers = ccNumbers.replace(/\-/g, "");
              
              const MAX_redact = 6;
              const MAX_RIGHT = 4;
              var len = ccNumbers.length;
              var lenredactd = Math.min(len, MAX_redact);
              var extra = Math.max(len - MAX_redact, 0);
              var lenRight = Math.min(extra, MAX_RIGHT);
              var lenLeft = len - lenredactd - lenRight;
              
              var extraLeft = ccNumbers.substr(0, lenLeft);
              var redactd = "*".repeat(lenredactd);
              var extraRight = ccNumbers.substr(lenLeft + lenredactd);
              
              //console.log(extraLeft + "," + redactd + "," + extraRight);
              return extraLeft + redactd + extraRight;
            }
          }  
          // ******* fin copia hacia global policy          
    - log:
        version: 2.0.0
        mode: send-only
